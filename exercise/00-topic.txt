================================================================================
这个文件收集了《深入理解计算机系统·第二版》的家庭作业的题目。关于这本书的详细信
息如下：

    深入理解计算机系统·第二版
    Randal E. Bryant  David R. O'Hallaron 著
    龚奕利 雷迎春 译
    机械工业出版社
    2012 年 7 月第 1 版第 8 次印刷
================================================================================

2.58 编写过程 is_little_endian，当在小端法机器上编译和运行时返回 1，在大端法机器
     上编译运行时返回 0.这个程序应该可以运行在任何机器上，无论机器的字长是多少。

2.59 编写一个 C 表达式，使它生成一个字，由 x 的最低有效字节和 y 中剩下的字节组成。
     对于运算数 x=0x89ABCDEF 和 y=0x76543210，就得到 0x765432EF。

2.60 假设我们将一个 w 位的字中的字节从 0（最低位）到 w/8-1（最高位）编号。写出下
     面的代码，它会返回一个无符号值，其中参数 x 的字节 i 被替换成字节 b：

     unsigned replace_byte(unsigned x, unsigned char b, int i);

     以下的一些示例，说明了这个函数如何工作：

     replace_byte(0x12345678, 0xAB, 2) --> 0x12AB5678
     replace_byte(0x12345678, 0xAB, 0) --> 0x123456AB

     位级整数编码规则

     在接下来的作业中，我们特意限制了你能使用的编程结构，来帮你更好地理解 C 语言
     的位级、逻辑和算数运算。在回答这些问题时，你的代码必须遵守下面这些规则：

     o 假设
       · 整数用补码形式表示。
       · 有符号数的右移是算数右移。
       · 数据类型 int 是 w 位长的。对于某些题目，会给定 w 的值，但是在其他情况下，
         只要 w 是 8 的整数倍，你的代码就应该能工作。你可以用表达式
         sizeof(int)<<3 来计算 w。
     o 禁止使用
       · 条件语句（if 或者 ?:）、循环、分支语句、函数调用和宏调用。
       · 除法、模运算和乘法。
       · 相对比较运算符（<、>、<=和>=）。
     o 允许的运算
       · 所有的位级和逻辑运算。
       · 左移和右移，但是位移的数量只能在 0 和 w-1 之间。
       · 加法和减法。
       · 相等（==）和不相等（!=）测试。（在有些题目中。也不允许这些运算。）
       · 整形常数 INT_MIN 和 INT_MAX。
       · 强制类型转换，无论是显式的还是隐式的。

     即使有这些条件的限制，你仍然可以选择描述性的变量名，并且使用注释来描述你的
     解决方案的逻辑，尽量提高代码的可读性。例如，下面这段代码从整数参数 x 中抽取
     出最高有效字节：

     /* Get most significant byte from x */
     int get_msb(int x) {
         /* Shift by w-8 */
         int shift_val = (sizeof(int)-1) << 3;
         /* Arithmetic shift */
         int xright = x >> shift_val;
         /* Zero all but LSB */
         return xright & 0xFF;
     }

2.64 写出代码实现如下函数：

     /* Return 1 when any even bit of x equals 1; 0 otherwise.
        Assume w=32 */

        int any_even_one(unsigned x);

     函数应该遵循位级整数编码规则，不过你可以假设数据类型 int 有 w=32 位。

2.66 写出代码实现如下的函数：

     /*
      * Generate mask indicating leftmost 1 in x.  Assume w=32.
      * For example 0xFF00 -> 0x8000, and 0x6600 --> 0x4000.
      * If x = 0, then return 0.
      */
     int leftmost_one(unsigned x);

     函数应该遵循位级整数编码规则，不过你可以假设数据类型 int 有 w=32 位。
     你的代码最多只能包含 15 个算数运算、位运算和逻辑运算。
     提示：先将 x 转换成形如 [0...011...1] 的位向量。

2.68 写出具有如下原型的函数的代码：

     /*
      * Make with least signficant n bits set to 1
      * Examples: n=6 --> 0x3f, n=17 --> 0x1FFFF
      * Assume 1 <= n <= w
      */
     int lower_bits(int x, int n);

     函数应该遵循位级整数编码规则。要注意 n = w 的情况。
