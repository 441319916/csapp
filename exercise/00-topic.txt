================================================================================
这个文件收集了《深入理解计算机系统·第二版》的家庭作业的题目。关于这本书的详细信
息如下：

    深入理解计算机系统·第二版
    Randal E. Bryant  David R. O'Hallaron 著
    龚奕利 雷迎春 译
    机械工业出版社
    2012 年 7 月第 1 版第 8 次印刷
================================================================================

2.58 编写过程 is_little_endian，当在小端法机器上编译和运行时返回 1，在大端法机器
     上编译运行时返回 0.这个程序应该可以运行在任何机器上，无论机器的字长是多少。

2.59 编写一个 C 表达式，使它生成一个字，由 x 的最低有效字节和 y 中剩下的字节组成。
     对于运算数 x=0x89ABCDEF 和 y=0x76543210，就得到 0x765432EF。

2.60 假设我们将一个 w 位的字中的字节从 0（最低位）到 w/8-1（最高位）编号。写出下
     面的代码，它会返回一个无符号值，其中参数 x 的字节 i 被替换成字节 b：

     unsigned replace_byte(unsigned x, unsigned char b, int i);

     以下的一些示例，说明了这个函数如何工作：

     replace_byte(0x12345678, 0xAB, 2) --> 0x12AB5678
     replace_byte(0x12345678, 0xAB, 0) --> 0x123456AB

     位级整数编码规则

     在接下来的作业中，我们特意限制了你能使用的编程结构，来帮你更好地理解 C 语言
     的位级、逻辑和算数运算。在回答这些问题时，你的代码必须遵守下面这些规则：

     o 假设
       · 整数用补码形式表示。
       · 有符号数的右移是算数右移。
       · 数据类型 int 是 w 位长的。对于某些题目，会给定 w 的值，但是在其他情况下，
         只要 w 是 8 的整数倍，你的代码就应该能工作。你可以用表达式
         sizeof(int)<<3 来计算 w。
     o 禁止使用
       · 条件语句（if 或者 ?:）、循环、分支语句、函数调用和宏调用。
       · 除法、模运算和乘法。
       · 相对比较运算符（<、>、<=和>=）。
     o 允许的运算
       · 所有的位级和逻辑运算。
       · 左移和右移，但是位移的数量只能在 0 和 w-1 之间。
       · 加法和减法。
       · 相等（==）和不相等（!=）测试。（在有些题目中。也不允许这些运算。）
       · 整形常数 INT_MIN 和 INT_MAX。
       · 强制类型转换，无论是显式的还是隐式的。

     即使有这些条件的限制，你仍然可以选择描述性的变量名，并且使用注释来描述你的
     解决方案的逻辑，尽量提高代码的可读性。例如，下面这段代码从整数参数 x 中抽取
     出最高有效字节：

     /* Get most significant byte from x */
     int get_msb(int x) {
         /* Shift by w-8 */
         int shift_val = (sizeof(int)-1) << 3;
         /* Arithmetic shift */
         int xright = x >> shift_val;
         /* Zero all but LSB */
         return xright & 0xFF;
     }

2.61 写一个 C 表达式，在下列描述的条件下产生 1，而在其他情况下得到 0。假设 x 是
     int 类型。

     A. x 的任何位都等于 1
     B. x 的任何位都等于 0
     C. x 的最高有效字节中的位都等于 1
     D. x 的最低有效字节中的位都等于 0

     代码应该遵循位级整数编码规则，另外还有一个限制，你不能使用相等（==）和不相
     等（==）测试。

2.62 编写一个函数 int_shifts_are_logical()，在对 int 类型的数使用算术右移的机器
     上运行时，这个函数生成 1，而其他情况下生成 0。你的代码应该可以运行在任何字
     长的机器上。在几种机器上测试你的代码。

2.63 将下面的 C 函数代码补充完整。函数 srl 用算术右移（由值 xsra 给出）来完成逻
     辑右移，后面的其他操作不包括右移或者除法。函数 sra 用逻辑右移（由值 xsrl 给
     出）来完成算术右移，后面的其他操作不包括右移或者除法。可以通过计算
     8*sizeof(int) 来确定数据类型 int 中的位数 w。位移量 k 的取值范围位 0~w-1。

     int sra(int x, int k) {
         /* Perform shift logically */
         int xsrl = (unsigned) x >> k;
         .
         .
         .
     }

     unsigned srl(unsigned x, int k) {
         /* Perform shift arithmetically */
         unsigned xsra = (int) x >> k;
         .
         .
         .
     }

2.64 写出代码实现如下函数：

     /* Return 1 when any even bit of x equals 1; 0 otherwise.
        Assume w=32 */

        int any_even_one(unsigned x);

     函数应该遵循位级整数编码规则，不过你可以假设数据类型 int 有 w=32 位。

2.65 写出代码实现如下函数：

     /* Return 1 when x contains an even number of 1s; 0 otherwise.
        Assume w=32 */
     int even_ones(unsigned x);

     函数应该遵循位级编码规则，不过你可以假设数据类型 int 有 w=32 位。
     你的代码最多只能包含 12 个算术运算、位运算和逻辑运算。

2.66 写出代码实现如下的函数：

     /*
      * Generate mask indicating leftmost 1 in x.  Assume w=32.
      * For example 0xFF00 -> 0x8000, and 0x6600 --> 0x4000.
      * If x = 0, then return 0.
      */
     int leftmost_one(unsigned x);

     函数应该遵循位级整数编码规则，不过你可以假设数据类型 int 有 w=32 位。
     你的代码最多只能包含 15 个算数运算、位运算和逻辑运算。
     提示：先将 x 转换成形如 [0...011...1] 的位向量。

2.67 给你一个任务，编写一个过程 int_size_is_32()，当在一个 int 是 32 位的机器上
     运行时，该程序产生 1，而其他情况则产生 0。不允许使用 sizeof 运算符。下面是
     开始时的尝试：

     /* The following code does not run properly on some machines */
     int bad_int_size_is_32() {
         /* Set most significant bit (msb) of 32-bit machine */
         int set_msb = 1 << 31;
         /* Shift past msb of 32-bit word */
         int beyond_msb = 1 << 32;

         /* set_msb is nonzero when word size >= 32
            beyond_msb is zero when word size <= 32 */
         return set_msb && !beyond_msb;
     }

     当在 SUN SPARC 这样的 32 位机器上编译并运行时，这个过程返回的却是 0。下面的
     编译器信息给了我们一个问题的指示：

     warning: left shift count >= width of type

     A. 我们的代码在哪个方面没有遵守 C 语言标准？
     B. 修改代码，使得它在 int 至少为 32 位的任何机器上都能正确运行。
     C. 修改代码，使得它在 int 至少位 16 位的任何机器上都能正确运行。

2.68 写出具有如下原型的函数的代码：

     /*
      * Make with least signficant n bits set to 1
      * Examples: n=6 --> 0x3f, n=17 --> 0x1FFFF
      * Assume 1 <= n <= w
      */
     int lower_bits(int x, int n);

     函数应该遵循位级整数编码规则。要注意 n = w 的情况。

2.70 写出具有如下原型的函数的代码：

     /*
      * Return 1 when x can be represented as an n-bit, 2's complement
      * number; 0 otherwise
      * Assume 1 <= n <= w
      */
     int fits_bits(int x, int n);

     函数应该遵循位级整数编码规则。

2.71 你刚刚开始在一家公司工作，他们要实现一组过程来操作一个数据结构，要将 4 个有
     符号字节封装成一个 32 位 unsigned。一个字中的字节从 0（最低有效字节）编号到
     3（最高有效字节）。分配给你的任务是：为一个使用补码运算和算数右移的机器编写
     一个具有如下原型的函数：

     /* Declaration of data type where 4 bytes are packed
        into an unsigned */
     typedef unsigned packed_t;

     /* Extract byte from word.  Return as signed integer */
     int xbyte(packed_t word, int bytenum);

     也就是说，函数会抽取出指定的字节，再把它符号扩展为一个 32 位 int。你的前任
     （因为水平不够高而被解雇了）编写了下面的代码：

     /* Failed attempt at xbyte */
     int xbyte(packed_t word, int bytenum)
     {
          return (word >> (bytenum << 3)) & 0xFF;
     }

     A. 这段代码错在哪里？
     B. 给出函数的正确实现，只能使用左右移位和一个减法。
