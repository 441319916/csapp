================================================================================
这个文件收集了《深入理解计算机系统·第二版》的家庭作业的题目。关于这本书的详细信
息如下：

    深入理解计算机系统·第二版
    Randal E. Bryant  David R. O'Hallaron 著
    龚奕利 雷迎春 译
    机械工业出版社
    2012 年 7 月第 1 版第 8 次印刷
================================================================================

2.58 编写过程 is_little_endian，当在小端法机器上编译和运行时返回 1，在大端法机器
     上编译运行时返回 0.这个程序应该可以运行在任何机器上，无论机器的字长是多少。

2.59 编写一个 C 表达式，使它生成一个字，由 x 的最低有效字节和 y 中剩下的字节组成。
     对于运算数 x=0x89ABCDEF 和 y=0x76543210，就得到 0x765432EF。

2.60 假设我们将一个 w 位的字中的字节从 0（最低位）到 w/8-1（最高位）编号。写出下
     面的代码，它会返回一个无符号值，其中参数 x 的字节 i 被替换成字节 b：

     unsigned replace_byte(unsigned x, unsigned char b, int i);

     以下的一些示例，说明了这个函数如何工作：

     replace_byte(0x12345678, 0xAB, 2) --> 0x12AB5678
     replace_byte(0x12345678, 0xAB, 0) --> 0x123456AB

     位级整数编码规则

     在接下来的作业中，我们特意限制了你能使用的编程结构，来帮你更好地理解 C 语言
     的位级、逻辑和算数运算。在回答这些问题时，你的代码必须遵守下面这些规则：

     o 假设
       · 整数用补码形式表示。
       · 有符号数的右移是算数右移。
       · 数据类型 int 是 w 位长的。对于某些题目，会给定 w 的值，但是在其他情况下，
         只要 w 是 8 的整数倍，你的代码就应该能工作。你可以用表达式
         sizeof(int)<<3 来计算 w。
     o 禁止使用
       · 条件语句（if 或者 ?:）、循环、分支语句、函数调用和宏调用。
       · 除法、模运算和乘法。
       · 相对比较运算符（<、>、<=和>=）。
     o 允许的运算
       · 所有的位级和逻辑运算。
       · 左移和右移，但是位移的数量只能在 0 和 w-1 之间。
       · 加法和减法。
       · 相等（==）和不相等（!=）测试。（在有些题目中。也不允许这些运算。）
       · 整形常数 INT_MIN 和 INT_MAX。
       · 强制类型转换，无论是显式的还是隐式的。

     即使有这些条件的限制，你仍然可以选择描述性的变量名，并且使用注释来描述你的
     解决方案的逻辑，尽量提高代码的可读性。例如，下面这段代码从整数参数 x 中抽取
     出最高有效字节：

     /* Get most significant byte from x */
     int get_msb(int x) {
         /* Shift by w-8 */
         int shift_val = (sizeof(int)-1) << 3;
         /* Arithmetic shift */
         int xright = x >> shift_val;
         /* Zero all but LSB */
         return xright & 0xFF;
     }

2.61 写一个 C 表达式，在下列描述的条件下产生 1，而在其他情况下得到 0。假设 x 是
     int 类型。

     A. x 的任何位都等于 1
     B. x 的任何位都等于 0
     C. x 的最高有效字节中的位都等于 1
     D. x 的最低有效字节中的位都等于 0

     代码应该遵循位级整数编码规则，另外还有一个限制，你不能使用相等（==）和不相
     等（==）测试。

2.62 编写一个函数 int_shifts_are_logical()，在对 int 类型的数使用算术右移的机器
     上运行时，这个函数生成 1，而其他情况下生成 0。你的代码应该可以运行在任何字
     长的机器上。在几种机器上测试你的代码。

2.63 将下面的 C 函数代码补充完整。函数 srl 用算术右移（由值 xsra 给出）来完成逻
     辑右移，后面的其他操作不包括右移或者除法。函数 sra 用逻辑右移（由值 xsrl 给
     出）来完成算术右移，后面的其他操作不包括右移或者除法。可以通过计算
     8*sizeof(int) 来确定数据类型 int 中的位数 w。位移量 k 的取值范围位 0~w-1。

     int sra(int x, int k) {
         /* Perform shift logically */
         int xsrl = (unsigned) x >> k;
         .
         .
         .
     }

     unsigned srl(unsigned x, int k) {
         /* Perform shift arithmetically */
         unsigned xsra = (int) x >> k;
         .
         .
         .
     }

2.64 写出代码实现如下函数：

     /* Return 1 when any even bit of x equals 1; 0 otherwise.
        Assume w=32 */

        int any_even_one(unsigned x);

     函数应该遵循位级整数编码规则，不过你可以假设数据类型 int 有 w=32 位。

2.65 写出代码实现如下函数：

     /* Return 1 when x contains an even number of 1s; 0 otherwise.
        Assume w=32 */
     int even_ones(unsigned x);

     函数应该遵循位级编码规则，不过你可以假设数据类型 int 有 w=32 位。
     你的代码最多只能包含 12 个算术运算、位运算和逻辑运算。

2.66 写出代码实现如下的函数：

     /*
      * Generate mask indicating leftmost 1 in x.  Assume w=32.
      * For example 0xFF00 -> 0x8000, and 0x6600 --> 0x4000.
      * If x = 0, then return 0.
      */
     int leftmost_one(unsigned x);

     函数应该遵循位级整数编码规则，不过你可以假设数据类型 int 有 w=32 位。
     你的代码最多只能包含 15 个算数运算、位运算和逻辑运算。
     提示：先将 x 转换成形如 [0...011...1] 的位向量。

2.67 给你一个任务，编写一个过程 int_size_is_32()，当在一个 int 是 32 位的机器上
     运行时，该程序产生 1，而其他情况则产生 0。不允许使用 sizeof 运算符。下面是
     开始时的尝试：

     /* The following code does not run properly on some machines */
     int bad_int_size_is_32() {
         /* Set most significant bit (msb) of 32-bit machine */
         int set_msb = 1 << 31;
         /* Shift past msb of 32-bit word */
         int beyond_msb = 1 << 32;

         /* set_msb is nonzero when word size >= 32
            beyond_msb is zero when word size <= 32 */
         return set_msb && !beyond_msb;
     }

     当在 SUN SPARC 这样的 32 位机器上编译并运行时，这个过程返回的却是 0。下面的
     编译器信息给了我们一个问题的指示：

     warning: left shift count >= width of type

     A. 我们的代码在哪个方面没有遵守 C 语言标准？
     B. 修改代码，使得它在 int 至少为 32 位的任何机器上都能正确运行。
     C. 修改代码，使得它在 int 至少位 16 位的任何机器上都能正确运行。

2.68 写出具有如下原型的函数的代码：

     /*
      * Make with least signficant n bits set to 1
      * Examples: n=6 --> 0x3f, n=17 --> 0x1FFFF
      * Assume 1 <= n <= w
      */
     int lower_bits(int x, int n);

     函数应该遵循位级整数编码规则。要注意 n = w 的情况。

2.69 写出具有如下原型的函数的代码：

     /*
      * Do rotating right shift.  Assume 0 <= n < w
      * Examples when x = 0x12345678 and w = 32:
      *     n=4 -> 0x81234567, n=20 -> 0x45678123
      */
     unsigned rotate_right(unsigned x, int n);

     函数应该遵循位级整数编码规则。要注意 n = 0 的情况。

2.70 写出具有如下原型的函数的代码：

     /*
      * Return 1 when x can be represented as an n-bit, 2's complement
      * number; 0 otherwise
      * Assume 1 <= n <= w
      */
     int fits_bits(int x, int n);

     函数应该遵循位级整数编码规则。

2.71 你刚刚开始在一家公司工作，他们要实现一组过程来操作一个数据结构，要将 4 个有
     符号字节封装成一个 32 位 unsigned。一个字中的字节从 0（最低有效字节）编号到
     3（最高有效字节）。分配给你的任务是：为一个使用补码运算和算数右移的机器编写
     一个具有如下原型的函数：

     /* Declaration of data type where 4 bytes are packed
        into an unsigned */
     typedef unsigned packed_t;

     /* Extract byte from word.  Return as signed integer */
     int xbyte(packed_t word, int bytenum);

     也就是说，函数会抽取出指定的字节，再把它符号扩展为一个 32 位 int。你的前任
     （因为水平不够高而被解雇了）编写了下面的代码：

     /* Failed attempt at xbyte */
     int xbyte(packed_t word, int bytenum)
     {
          return (word >> (bytenum << 3)) & 0xFF;
     }

     A. 这段代码错在哪里？
     B. 给出函数的正确实现，只能使用左右移位和一个减法。

2.72 给你一个任务，写一个函数，将整数 val 复制到缓冲区 buf 中，但是只有缓冲区
     buf 中，但是只有当缓冲区中有足够可用的空间时，才执行复制。

     你写的代码如下：

     /* Copy integer into buffer if space is available */
     /* WARNING: The following code is buggy */
     void copy_int(int val, void *buf, int maxbytes) {
         if (maxbytes-sizeof(val) >= 0)
             memcpy(buf, (void *)&val, sizeof(val));
     }

     这段代码使用了库函数 memcpy。虽然在这里用这个函数有点刻意，因为我们只是想复
     制一个 int，但是说明了一种复制较大数据结构的常见方法。

     你仔细地测试了这段代码后发现，哪怕 maxbytes 很小的时候，它也能把值复制到缓
     冲区中。

     A. 解释为什么代码中的条件测试总是成功。提示：sizeof 运算符返回类型为 size_t 的值。
     B. 你该如何重写这个条件测试，使之工作正确。

2.73 写出具有如下原型的函数的代码：

     /* Addition that saturates to TMin or TMax */
     int saturating_add(int x, int y);

     同正常的补码溢出的方式不同，当正溢出时，saturating_add 返回 TMax，负溢出时，
     返回 TMin。这种运算常常用在执行数字信号处理的程序中。

     你的函数应该遵循位级整数编码规则。

2.74 写出具有如下原型的函数的代码：

     /* Determine whether subtracting arguments will cause overflow */
     int tsub_ovf(int x, int y);

     如果计算 x-y 导致溢出，这个函数就返回 1。

2.75 假设我们想要计算 x·y 的完整的 2w 位表示，其中，x 和 y 都是无符号数，并且运
     行在数据类型 unsigned 是 w 位的机器上。乘积的低 w 位能够用表达式 x·y 计算，
     所以，我们只需要一个具有下列原型的函数：

     unsigned unsigned_high_prod(unsigned x, unsigned y);

     这个函数计算无符号变量 x·y 的高 w 位。
     我们使用一个具有下面原型的库函数：

     int signed_high_prod(int x, int y);

     它计算在 x 和 y 采用补码形式的情况下，x·y 的高 w 位。编写代码调用这个过程，
     以实现用无符号数为参数的函数。验证你的解答的正确性。

     提示：看看等式（2-18）的推导中，有符号乘积 x·y 和无符号乘积 x'·y' 之间的关
     系。

2.76 假设我们有一个任务：生成一段代码，将整数变量 x 乘以不同的常数因子 K。为了提
     高效率，我们想只使用 +、- 和 << 运算。对于下列的 K 的值，写出执行乘法运算的
     C 表达式，每个表达式中最多使用 3 个运算。

     A. K=5
     B. K=9
     C. K=30
     D. K=-56

2.77 写出具有如下原型的函数的代码：

     /* Divide by power of two.  Assume 0 <= k < w-1 */
     int divide_power2(int x, int k);

     该函数要用正确的舍入计算 x/2^k，并且应该遵循位级整数编码规则。

2.78 写出函数 mul5div8 的代码，对于整数参数 x，计算 5*x/8，但是要遵循位级整数编
     码规则。你的代码计算 5*x 也会产生溢出。

2.79 写出函数 fiveeighths 的代码，对于整数参数 x，计算 5/8x 的值，向零舍入。它不
     会溢出。函数应该遵循整数位级编码规则。

2.80 编写 C 表达式产生如下位模式，其中 a^n 表示符号 a 重复 n 次。假设一个 w 位的
     数据类型。你的代码可以包含对参数 m 和 n 的引用，它们分别表示 m 和 n 的值，但
     是不能使用表示 w 的参数。

     A. 1^(w-n)0^n
     B. 0^(w-n-m)1^n0^m

2.81 我们在一个 int 类型值为 32 位的机器上运行程序。这些值以补码形式表示，而且它
     们都是算术右移的。unsigned 类型的值也是 32 位的。

     我们产生随机数 x 和 y，并且把它们转换成无符号数，显示如下：

     /* Create some arbitrary values */
     int x = random();
     int y = random();
     /* Convert to unsigned */
     unsigned ux = (unsigned) x;
     unsigned uy = (unsigned) y;

     对于下列每个 C 表达式，你要指出表达式是否总是为 1。如果它总是为 1，那么请描
     述其中的数学原理。否则，列举一个使它为 0 的参数示例。

     A. (x > y) == (-x < -y)
     B. ((x + y) << 5) + x - y == 31 * y + 33 * x
     C. ~x + ~y == ~(x + y)
     D. (int)(ux - uy) == -(y - x)
     E. ((x >> 1) << 1) <= x

2.82 一些数字的二进制表示是由形如 0.yyyyyy... 的无穷串组成的，其中 y 是一个 k 位
     的序列。例如，1/3 的二进制表示是 0.01010101...（y=01），而 1/5 的二进制表示
     是0.001100110011（y=0011）。

     A. 设 Y=B2Uk(y)，也就是说，这个数具有二进制表示 y。给出一个由 Y 和 k 组成的
        公式表示这个无穷串的值。提示：请考虑将二进制小数点右移 k 位的结果。

     B. 对于下列 y 的值，串的数值是多少？

        (a) 001
        (b) 1001
        (c) 000111

2.83 填写下列程序的返回值，这个程序是测试它的第一个参数是否大于或者等于第二个参
     数。假定函数 f2u 返回一个无符号 32 位数字，其位表示与它的浮点参数相同。你可
     以假设两个参数都不是 NaN。两种 0，+0 和 -0 都认为是相等的。

     int float_ge(float x, float y) {
         unsigned ux = f2u(x);
         unsigned uy = f2u(y);

         /* Get the sign bits */
         unsigned sx = ux >> 31;
         unsigned sy = uy >> 31;

         /* Given an expression using only ux, uy, sx, sy */
         return ________;
     }

2.84 给定一个浮点格式，有 k 位指数和 n 位小数，对于小列数，写出阶码 E、尾数 M、
     小数 f 和值 V 的公式。另外，请描述其位表示。

     A. 数 5.0。
     B. 能够被准确描述的最大奇整数。
     C. 最小的规格化数的倒数。

2.89 分配给你一个任务，编写一个 C 函数来计算 2^x 的浮点表示。你意识到完成这个任
     务的最好方法是直接创建结果的 IEEE 单精度表示。当 x 太小时，你的程序将返回
     0.0。当 x 太大时，它会返回 +oo。填写下列代码的空白部分，以计算出正确的结果。
     假设函数 u2f 返回的浮点值与它的无符号参数有相同的位表示。

2.90 大约在公元前 250 年，希腊数学家阿基米德证明了 223/71 < PI < 22/7。如果当时
     有一台计算机和标准库 <math.h>，他就能够确定 n 的单精度浮点近似值的十六进制
     表示为 0x40490FDB。当然，所有的这些都只是近似值，因为 PI 不是有理数。

     A. 这个浮点值表示的二进制小数是多少？
     B. 22/7 的二进制小数表示是什么？提示：参见家庭作业 2.82。
     C. 这两个 22/7 的近似值从哪一位（相对于二进制小数点）开始不同的？

     位级浮点编码规则

     在接下来的题目中，你要写的代码要实现浮点函数在浮点数的位级表示上直接运算。
     你的代码应该完全遵循 IEEE 浮点运算的规则，包括当需要舍入时，要使用向偶数舍
     入的方式。为此，我们定义数据类型 float_bits 等价于 unsigned：

     /* Access bit-level representation floating-point number */
     typedef unsigned float_bits;

     你的代码中不使用数据类型 float，而要使用 float_bits。你可以使用数据类型 int
     和 unsigned，包括无符号和整数常数和运算。你不可以使用任何联合、结构和数组。
     更重要的是，你不能使用任何浮点数据类型、运算或者常数。取而代之的是，你的代
     码应该执行实现这些指定的浮点运算的位操作。

     下面的函数说明了对这些规则的使用。对于参数 f，如果 f 是非规格化的，该函数返
     回 ±0（保持 f 的符号），否则，返回 f。

     /* If f is denorm, return 0. Otherwise, return f */
     float_bits float_denorm_zero(float_bits f) {
         /* Decompose bit representation into parts */
         unsigned sign = f>>31;
         unsigned exp = f>>23 & 0xFF;
         unsigned frac = f    & 0x7FFFFF;
         if (exp == 0) {
             /* Denormalized.  Set fraction to 0 */
             frac = 0;
         }
         /* Reassemble bits */
         return (sign << 31) | (exp << 23) | frac;
     }

2.91 遵循位级浮点编码规则，实现具有如下原型的函数：

     /* Compute |f|.  If f is NaN, then return f. */
     float_bits float_absval(float_bits f);

     对于浮点数 f，这个函数计算 |f|。如果 f 是 NaN，你的函数应该简单地返回 f。测
     试你的函数，对参数 f 可以取的所有 2^32 个值求值，将结果与你实用机器的浮点运
     算得到的结果相比较。

2.93 遵循位级浮点编码规则，实现具有如下原型的函数：

     /* Compute 0.5*f.  If f is NaN, then return f. */
     float_bits float_half(float_bits f);

     对于浮点数 f，这个函数计算 0.5*f。如果 f 是 NaN，你的函数应该简单返回 f。测
     试你的函数，对参数 f 可以取的所有 2^32 个值求值，将结果与你使用机器的浮点运
     算得到的结果相比较。
