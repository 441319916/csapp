第 3 章 程序的机器级表示

超线程（hyperthreading）：在一个处理器上同时运行两个程序。
        p104

IA32（Intel Architecture 32-bit）：Intel 32位体系结构
        p104

计算机系统使用了多种不同形式的抽象，利用更简单的抽象模型来隐藏实现的细节。对于机
器级编程来说，其中两种抽象尤为重要。

第一种是机器级程序的格式和行为，定义为指令集体系结构（Instruction set
architecture, ISA），它定义了处理器状态、指令的格式，以及每条指令对状态的影响。

第二种抽象是，机器级程序使用的存储器地址是虚拟地址，提供的存储器模型看上去是一个
非常大的字节数组。
        p106

虽然 C 语言提供了一种模型，可以在存储器中声明和分配各种数据类型的对象，但是机器
代码只是简单地将存储器看成是一个很大的、按字节寻址的数组。C 语言中的聚合数据类型，
例如数组和结构，在机器代码中用连续的一组字节来表示。即使是标量数据类型，汇编代码
也不区分有符号或无符号整数，不区分各种类型的指针，甚至不区分指针和整数。
        p106~p107

(gdb) x/17xb sum

这条命令告诉 GDB 检查（简写为“x”）17 个十六进制格式（也简写为“x”）的字节（简
写为“b”）。
        p108

unix> gcc -O1 -S -masm=intel code.c
        p110

由于是从 16 位体系结构扩展成 32 位的，Intel 用术语“字”（word）表示 16 位数据类型。
因此，称 32 位数为“双字”（double words），称 64 位数位“四字”（quad words）。我们
后面遇到的大多数指令都是对字节或双字操作的。
        p111

大多数指令有一个或多个操作数（operand），指示出执行一个操作中要引用的源数据值，以
及放置结果的目标位置。IA32 支持多种操作数格式。源数据值可以以常数形式给出，或是从
寄存器或存储器中读出。结果可以存放在寄存器或存储器中。因此，各种不同的操作数的可
能性被分为三种类型。

第一种类型是立即数（immediate），也就是常数值。第二种类型是寄存器（register），它
表示某个寄存器的内容。第三种操作数是存储器（memory）引用，它会根据计算出来的地址
（通常称为有效地址）访问某个存储器位置。
        p112~p113

C 语言中所谓的“指针”其实就是地址，局部变量通常是保存在寄存器中，而不是在存储器
中。寄存器访问比存储器访问要快得多。
        p117

机器代码提供两种基本的低级机制来实现有条件的行为：测试数据值，然后根据测试的结果
来改变控制流或者数据流。

数据相关的控制流是实现有条件行为的更通用和更常见的方法。
        p123

除了整数寄存器，CPU 还维护着一组单个位的条件码（condition code）寄存器，它们描述
了最近的算术或逻辑操作的属性。

CF: 进位标志。最近的操作使最高位产生了进位。可以用来检查无符号操作数的溢出。
ZF: 零标志。最近的操作得出的结果为 0。
SF: 符号标志。最近的操作得到的结果为负数。
OF: 溢出标志。最近的操作数导致一个补码溢出--正溢出或负溢出。
        p124

条件码通常不会直接读取，常用的使用方法有三种：
1. 可以根据条件码的某个组合，将一个字节设置为 0 或者 1
2. 可以条件跳转到程序的某个其他的部分
3. 可以有条件地传送数据
        p125

在产生目标代码文件时，汇编器会确定所有带标号指令的地址，并将跳转目标（目的指令的
地址）编码为跳转指令的一部分。
        p127

jmp 指令是无条件跳转，它可以是直接跳转，即跳转目标是作为指令的一部分编码的；也可
以是间接跳转，即跳转目标是从寄存器或存储器位置中读出的。
        p127

理解跳转指令的目标如何编码，对研究链接非常重要。
        p127

跳转指令有几种不同的编码，但是最常用的都是 PC（Program Counter）相关的
（PC-relative）。它们会将目标指令的地址与紧跟在跳转指令后面那条指令的地址之间的
差作为编码。
        p127

当执行与 PC 相关的寻址时，程序计数器的值是跳转指令后面的那条指令的地址，而不是跳
转指令本身的地址。这种惯例可以追溯到早期实现，当时的处理器会将更新程序计数器作为
执行一条指令的第一步。
        p129

C 语言中三种形式的所有循环 -- do-while、while 和 for -- 都可以用一种简单的策略来
翻译，产生包含一个或多个条件分支的代码。控制的条件转移为循环翻译成机器代码提供了
基本机制。
        p138

数据的条件转移是一种替代的策略。这种方法先计算一个条件操作的两种结果，然后再根据
条件是否满足从而选取一个。只有在一些受限制的情况下，这种策略才可行，但是如果可行，
就可以用一条简单的条件传送指令来实现它。条件传送指令更好地匹配了现代处理器的性能
特性。
        p139

从 1995 年的 PentiumPro 开始，近代 IA32 处理器都拥有条件传送指令，这些指令会根据
条件码的值，选择要么什么都不做，要么将一个值复制到一个寄存器。
        p140

基于条件数据传送的代码比基于条件控制转移的代码性能好，其中的原因，是因为现代处理
器通过使用流水线（pipelining）来获得高性能。

在流水线中，一条指令的处理要经过一系列的阶段，每个阶段执行所需要操作的一小部分。
这种方法通过重叠连续指令的步骤来获得高性能。例如，在取一条指令的时候，执行它前面
一条指令的算术运算。要做到这一点，要求能够事先确定要执行指令的序列，这样才能保持
流水线中充满了待执行的指令。

错误预测一个跳转要求处理器丢掉它为该跳转后所有指令已经做了的工作，然后再开始用从
正确位置处起始的指令区填充流水线。这样一个错误预测会招致很严重的惩罚。大约 20~40
时钟周期的浪费，导致程序性能的严重下降。
        p141

T_arg(p) = (1-p)*T_ok + p*(T_ok+T_mp) = T_ok + p*T_mp
        p141

使用条件传送也不是总会改进代码的效率。编译器必须考虑浪费的计算和由于分支预测错误
所造成的性能处罚之间的相对性能。说实话，编译器并不具有足够的信息来做出可靠的决定。
        p141

总的来说，条件数据传送提供了一种用条件控制转移来实现条件操作的替代策略。它们只能
用于很受限制的情况，但是这些情况还是相当常见的，而且充分利用了现代处理器的运行方
式。
        p141
