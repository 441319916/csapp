第 7 章 链接

链接（linking）是将各种代码和数据部分收集起来并组合成为一个单一文件的过程，这个
文件可被加载（或被拷贝）到存储器并执行。

链接可以执行于编译时（compile time），也就是在源代码被翻译成机器代码时；也可以执
行于加载时（load time），也就是在程序被加载器（loader）加载到存储器并执行时；甚
至执行于运行时（run time），由应用程序来执行。

在早期的计算机系统中，链接是手动执行的。在现代系统中，链接是由叫做链接器（linker）
的程序自动执行的。
        p448

链接器在软件开发中扮演着一个关键的角色，因为它们使得分离编译（separate
compilation）成为可能。我们不用将一个大型的应用程序组织为一个巨大的源文件，而是
可以把它分解为更小、更好管理的模块，可以独立地修改和编译这些模块。当我们改变这些
模块中的一个时，只需简单地重新编译它，并重新链接应用，而不必重新编译其他文件。
        p448

为什么要这么麻烦地学习关于链接的知识呢？

    o 理解链接器将帮助你构造大型程序

      构造大型程序的程序员经常会遇到由于缺少模块、缺少库或者不兼容的库版本引起的
      链接器错误。除非你理解链接器是如何解析引用、什么是库以及链接器是如何使用库
      来解析引用的，否则这类错误将令你感到迷惑和挫败。

    o 理解链接器将帮助你避免一些危险的编程错误

      UNIX 链接器解析符号引用时所做的决定可以不动声色地影响你程序的正确性。在默
      认情况下，错误地定义多个全局变量的程序将通过链接器，而不产生任何警告信息。
      由此得到的程序会产生令人迷惑的运行时行为，而且非常难以调试。我们将向你展示
      这是如何发生的，以及该如何避免它。

    o 理解链接器将帮助你理解语言的作用域规则是如何实现的

      例如，全局和局部变量之间的区别是什么？当你定义一个具有 static 属性的变量或
      函数时，到底实际意味着什么？

    o 理解链接器将帮助你理解其他重要的系统概念

      链接器产生的可执行目标文件在重要的系统功能中扮演着关键角色，比如加载和运行
      程序、虚拟存储器、分页和存储器映射。

    o 理解链接器将使你能够利用共享库

      多年以来，链接都被认为是相当简单和无趣的。然而，随着共享库和动态链接在现代
      操作系统中重要性的日益加强，链接成为一个复杂的过程，它为知识丰富的程序员提
      供了强大的能力。比如，许多软件产品在运行时使用共享库来升级压缩包装的
      （shrink-wrapped）二进制程序。还有，大多数 Web 服务器都依赖于共享库的动态
      链接来提供动态内容。
        p448

无论是什么样的操作系统、ISA 或者目标文件格式，基本的链接概念是通用的，认识到这一
点是很重要的。
        p448

大多数编译系统提供编译驱动程序（compiler driver），它代表用户在需要时调用语言处
理器、编译器、汇编器和链接器。比如，要用 GNU 编译系统构造示例程序，我们就要通过
在外壳中输入下列命令行来调用 GCC 驱动程序：

    unix> gcc -O2 -g -o p main.c swap.c

驱动程序在将示例程序从 ASCII 码源文件翻译成可执行目标文件时的行为：

1. 运行 C 预处理其（cpp），将 C 源程序 main.c 翻译成一个 ASCII 码的中间文件 main.i

    unix> cpp [other arguments] main.c /tmp/main.i

2. 运行 C 编译器（cc1），它将 main.i 翻译成一个 ASCII 汇编语言文件 main.s

    unix> cc1 /tmp/main.c -O2 [other arguments] -o /tmp/main.s

3. 运行汇编器（as），它将 main.s 翻译成一个可重定位目标文件（relocatable object file）main.o:

    unix> as [other arguments] -o /tmp/main.o /tmp/main.s

4. 运行链接器 ld，将 main.o 和 swap.o（驱动程序经过相同的过程生成 swap.o） 以及一
   些必要的系统目标文件组合起来，创建一个可执行目标文件（executable object file）
   p：

    unix> ld -o p [system object files and args] /tmp/main.o /tmp/swap.o
        p449~p450

要运行可执行文件 p，我们在 UNIX 外壳的命令行上输入它的名字：

    unix> ./p

外壳调用操作系统中一个叫做加载器的函数，它拷贝可执行文件 p 中的代码和数据到存储
器，然后将控制转移到这个程序的开头。
        p450

像 UNIX ld 程序这样的静态链接器（static linker）以一组可重定位目标文件和命令行参
数作为输入，生成一个完全链接的可以加载和运行的可执行目标文件作为输出。

输入的可重定位目标文件由各种不同的代码和数据节（section）组成。指令在一个节中，
初始化的全局变量在另一个节中，而未初始化的变量又在另外一个节中。
        p450

为了构造可执行文件，链接器必须完成两个主要任务：

    o 符号解析（symbol resolution）

      目标文件定义和引用符号。符号解析的目的是将每个符号引用刚好和一个符号定义联
      系起来

    o 重定位（relocation）

      编译器和汇编器生成从地址 0 开始的代码和数据节。链接器通过把每个符号定义与
      一个存储器位置联系起来，然后修改所有对这些符号的引用，使得他们指向这个存储
      器位置，从而重定位这些节

要记住关于链接器的一些基本事实：目标文件纯粹是字节块的集合。

这些块中，有些包含程序代码，有些则包含程序数据，而其他的则包含知道链接器和加载器
的数据结构。链接器将这些块连接起来，确定被连接块的运行时位置，并且修改代码和数据
块中的各种位置。

链接器对目标机器了解甚少。产生目标文件的编译器和汇编器已经完成了大部分工作。
        p450

目标文件有三种形式：

    o 可重定位目标文件

      包含二进制代码和数据，其形式可以在编译时与其他可重定位目标文件合并起来，创
      建一个可执行目标文件

    o 可执行目标文件

      包含二进制代码和数据，其形式可以被直接拷贝到存储器并执行

    o 共享目标文件

      一种特殊类型的可重定位目标文件，可以在加载或者运行时被动态地加载到存储器并
      链接
        p450

编译器和汇编器生成可重定位目标文件（包括共享目标文件）。链接器生成可执行目标文件。
从技术上来说，一个目标模块（objcet module）就是一个字节序列，而一个目标文件
（object file）就是一个存放在磁盘文件中的目标模块。
        p450

ELF头（ELF header）以一个 16 字节的序列开始，这个序列描述了生成该文件的系统的字的
大小和字节顺序。

ELF头 剩下的部分包含帮助链接器语法分析和解释目标文件的信息。其中包括 ELF头 的大小、
目标文件的类型（如可重定位、可执行或者是共享的）、机器类型（如 IA32）、节头部表
（section header table）的文件偏移，以及节头部表中的条目大小和数量。

不同节的位置和大小是由节头部表描述的，其中目标文件中每个节都有一个固定大小的条目
（entry）。夹在 ELF头 和节头部表之间的都是节。
        p451

每个可重定位目标模块 m 都有一个符号表，它包含 m 所定义和引用的符号的信息。在链接
器的上下文中，有三种不同的符号：

    o 全局符号（global）

      由 m 定义并能被其他模块引用的全局符号。全局链接器符号对应于非静态的 C 函数
      以及被定义为不带 C static 属性的全局变量

    o 外部符号(external)

      由其他模块定义并被模块 m 引用的全局符号。这些符号称为外部符号，应对与定义
      在其他模块中的 C 函数和变量

    o 本地符号（local）

      只被模块 m 定义和引用的本地符号。有的本地链接器符号对应与带 static 属性的
      C 函数和全局变量。这些符号在模块 m 中随处可见，但是不能被其他模块引用。目
      标文件中对应于模块 m 的节和相应的源文件的名字也能获得本地符号
        p452

认识到本地链接器符号和本地程序变量的不同是很重要的。.symtab 中的符号表不包含对应
于本地非静态程序变量的任何符号。这些符号在运行时在栈中被管理，链接器对此类符号不
感兴趣。
        p452

有趣的是，定义为带有 C static 属性的本地过程变量是不在栈中管理的。相反，编译器在
.data 和 .bss 中为每个定义分配空间，并在符号表中创建一个有唯一名字的本地链接器符
号。
        p452

符号表是由汇编器构造的，使用编译器输出到汇编语言 .s 文件的符号。.symtab 节中包含
ELF 符号表。这张符号表包含一个条目的数组。
        p453

每个符号都和目标文件的某个节相关联，由 section 字段表示，该字段也是一个到节头部
表的索引。有三个特殊的伪节（pseudo section），他们在节头部表中是没有条目的：

    o ABS

      代表不该被重定位的符号

    o UNDEF

      代表未定义的符号，也就是在本目标模块中引用，但是却在其他地方定义的符号

    o COMMON

      表示还未被分配位置的未初始化的数据目标
        p453

链接器解析符号引用的方法是将每个引用与它输入的可重定位目标文件的符号表中的一个确
定的符号定义联系起来。
        p454

对 C++ 和 Java 中链接器符号的毁坏（mangling）

C++ 和 Java 都允许重载方法，这些方法在源代码中有相同的名字，却有不同的参数列表。
那么链接器是如何区别这些不同的重载函数之间的差异呢？C++ 和 Java 中能使用重载函数，
是因为编译器将每个唯一的方法和参数列表组合编码成一个对链接器来说唯一的名字。

这种编码过程叫做毁坏（mangling），而相反的过程叫做恢复（demangling）。

幸运的是，C++ 和 Java 使用兼容的毁坏策略。一个被毁坏的类名字是由名字中字符的整数
数量，后面跟原始名字组成的。比如，类 Foo 被编码成 3Foo。方法被编码为原始方法名，
后面加上 __，加上被毁坏的类名，再加上每个参数的单个字母编码。比如，Foo::bar(int,
long)被编码为 bar__3Fooil。毁坏全局变量和模板名字的策略是相似的。
        p454~p455

实际上，所有的编译系统都提供一种机制，将所有相关的目标模块打包成为一个单独的文件，
称为静态库（static library）。它可以用作链接器的输入。当链接器构造一个输出的可执
行文件时，它只拷贝静态库里被应用程序引用的目标模块。
        p457

在 UNIX 系统中，静态库以一种称为存档（archive）的特殊文件格式存放在磁盘中。存档
文件是一组连接起来的可重定位目标文件的集合，有一个头部用来描述每个成员目标文件的
大小和位置。存档文件名由后缀 .a 标识。
        p458

在符号解析的阶段，链接器从左到右按照它们在编译器驱动程序命令行上出现的相同顺序来
扫描可重定位目标文件和存档文件。

在这次扫描中，链接器维持一个可重定位目标文件的集合 E（这个集合中的文件会被合并起
来形成可执行文件），一个未解析的符号（即引用了但是尚未定义的符号）集合 U，以及一
个在前面输入文件中已定义的符号集合 D。

初始时，E、U、D 都是空的。

    o 对于命令行上的每个输入文件 f，链接器会判断 f 是一个目标文件还是一个存档文
      件。如果 f 是一个目标文件，那么链接器把 f 添加到 E，修改 U 和 D 来反映 f
      中的符号定义和引用，并继续下一个输入文件。

    o 如果 f 是一个存档文件，那么链接器就尝试匹配 U 中未解析的符号和由存档文件成
      员定义的符号。如果某个存档文件成员 m，定义了一个符号来解析 U 中的一个引用，
      那么就将 m 加到 E 中，并且链接器修改 U 和 D 来反映 m 中的符号定义和引用。
      对存档文件中所有的成员目标文件都反复进行这个过程，直到 U 和 D 都不再发生变
      化。在此时，任何不包含在 E 中的成员目标文件都简单地被丢弃，而链接器将继续
      处理下一个输入文件。

    o 如果当链接器完成对命令行上输入文件的扫描后，U 是非空的，那么链接器就会输出
      一个错误并终止。否则，它会合并和重定位 E 中的目标文件，从而构建输出的可执
      行文件

不幸的是，这种算法会导致一些令人困扰的链接时错误，因为命令行上的库和目标文件的顺
序非常重要。在命令行中，如果定义一个符号的库出现在引用这个符号的目标文件之前，那
么引用就不能被解析，链接会失败。
        p460

关于库的一般准则是将它们放在命令行的结尾。
        p460
